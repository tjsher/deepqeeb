# DeepQeeb 设计方案 v2（含 Agent C）

## 确认的设计选择

✅ 文件目录**全局共享**，切换对话只切换上下文  
✅ 游戏预览**内嵌在对话框下方**  
✅ **必须登录**才能使用  
✅ Agent A 和 B **分开**，剧本对话可「一键进入」游戏对话  
✅ Agent C 作为**游戏运行时驱动**

---

## 一、Agent 职责重新定义

```
┌─────────────────────────────────────────────────────────────────┐
│                        DeepQeeb 架构                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐      │
│  │   Agent A    │    │   Agent B    │    │   Agent C    │      │
│  │   剧本编剧   │───→│   游戏导演   │───→│   游戏主持人 │      │
│  │              │    │              │    │              │      │
│  │ • 角色设定   │    │ • UI 设计    │    │ • 状态管理   │      │
│  │ • 剧情分支   │    │ • 代码生成   │    │ • 实时交互   │      │
│  │ • 世界观   │    │ • 素材生成   │    │ • 存档管理   │      │
│  └──────────────┘    └──────────────┘    └──────────────┘      │
│          │                   │                   │              │
│          ▼                   ▼                   ▼              │
│   ┌──────────────┐    ┌──────────────┐    ┌──────────────┐      │
│   │  剧本文件    │    │  游戏版本    │    │   存档数据   │      │
│   │  (Markdown)  │    │  (HTML/ESM)  │    │  (JSON)      │      │
│   └──────────────┘    └──────────────┘    └──────────────┘      │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Agent C 的特殊性

Agent C **不直接面向开发者**，而是面向**游戏玩家**：

| | Agent A (编剧) | Agent B (导演) | Agent C (主持人) |
|---|---|---|---|
| **用户** | 游戏开发者 | 游戏开发者 | 游戏玩家 |
| **输入** | 自然语言描述 | 剧本文件 + 指令 | 游戏内操作 |
| **输出** | 剧本/角色/剧情 | 可运行的 HTML 游戏 | 剧情推进 + 状态更新 |
| **存在形式** | IDE 对话框 | IDE 游戏预览 | 独立游戏页面 |
| **上下文** | 对话历史 | 游戏版本历史 | 当前存档状态 |

---

## 二、Agent C 技术方案

### 2.1 通信协议设计

Agent C 的输出需要**结构化**，便于前端解析：

```xml
<!-- Agent C 输出格式 -->
<dialogue>
  <speaker>角色A</speaker>
  <emotion>惊讶</emotion>
  <content>啊...好的!</content>
  <avatar_url>https://cdn.xxx.com/a.png</avatar_url>
</dialogue>

<state_update>
{
  "主角": {
    "背景": "A的男朋友"
  },
  "角色A": {
    "背景": "主角的女朋友"
  },
  "剧情进度": "第一章-表白成功",
  "可用选项": ["一起去吃饭", "先回家"] 
}
</state_update>

<function_call>
{
  "name": "check_inventory",
  "args": {"item": "戒指"}
}
</function_call>
```

### 2.2 状态管理策略

```typescript
// 存档数据结构 (save_slots 表)
interface GameSave {
  id: string;
  game_id: string;           // 关联的游戏版本
  user_id: string;           // 玩家用户ID
  slot_number: number;       // 存档槽位 (1-5)
  
  // 完整游戏状态 (Agent C 维护)
  state: {
    // 角色属性
    characters: {
      [roleId: string]: {
        name: string;
        attributes: Record<string, any>;
        relationships: Record<string, string>;
      }
    };
    
    // 全局变量
    variables: Record<string, any>;
    
    // 剧情进度
    progress: {
      currentChapter: string;
      completedEvents: string[];
      flags: Record<string, boolean>;
    };
    
    // 背包/物品
    inventory: Array<{
      itemId: string;
      name: string;
      quantity: number;
      metadata?: any;
    }>;
    
    // 对话历史 (最近 N 条，用于上下文)
    dialogueHistory: Array<{
      speaker: string;
      content: string;
      timestamp: number;
    }>;
  };
  
  created_at: timestamp;
  updated_at: timestamp;
}
```

### 2.3 运行时架构

```
玩家打开 /share/abc123
         │
         ▼
┌─────────────────────┐
│  加载游戏 HTML      │
│  (Agent B 生成)     │
├─────────────────────┤
│  - UI 组件          │
│  - 样式资源         │
│  - 剧本基础数据     │
└─────────────────────┘
         │
         ▼
┌─────────────────────┐
│  检查是否有存档     │
│  /api/saves?game=xxx│
├─────────────────────┤
│  有 → 加载存档      │
│  无 → 初始化新游戏  │
└─────────────────────┘
         │
         ▼
┌─────────────────────┐
│  WebSocket/SSE 连接 │
│  /api/game/stream   │
├─────────────────────┤
│  发送初始状态给     │
│  Agent C            │
└─────────────────────┘
         │
         ▼
┌─────────────────────┐
│  Agent C 驱动游戏   │
│  流式返回剧情+状态  │
└─────────────────────┘
```

### 2.4 存档机制

**自动存档：**
- 每次状态更新后自动保存
- 保存到 Supabase Realtime (或轮询)

**手动存档：**
- 玩家点击「存档」→ 选择槽位 (1-5)
- 覆盖或新建

**读档：**
- 游戏开始界面显示存档列表
- 游戏中可随时读档

---

## 三、更新后的数据模型

### 核心表结构

```typescript
// users 表 (Supabase Auth 扩展)
interface User {
  id: string;
  email: string;
  created_at: timestamp;
}

// files 表 (全局文件系统)
interface File {
  id: string;
  user_id: string;
  path: string;              // 文件路径，如 "/剧本/第一章.md"
  content: string;           // 文件内容
  type: 'script' | 'config' | 'asset';
  created_at: timestamp;
  updated_at: timestamp;
}

// conversations 表
interface Conversation {
  id: string;
  user_id: string;
  type: 'script' | 'game';
  title: string;
  
  // 关联的文件 (script 类型)
  related_files?: string[];  // file_id 数组
  
  // 关联的游戏版本 (game 类型)
  game_versions?: string[];  // game_id 数组
  
  // 关联的源剧本对话 (game 类型)
  source_conversation_id?: string;
  
  status: 'active' | 'archived';
  created_at: timestamp;
  updated_at: timestamp;
}

// messages 表
interface Message {
  id: string;
  conversation_id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  metadata?: {
    // 用于标记特殊消息
    type?: 'file_created' | 'file_updated' | 'game_generated';
    file_id?: string;
    game_id?: string;
  };
  created_at: timestamp;
}

// games 表 (游戏版本)
interface GameVersion {
  id: string;
  user_id: string;
  conversation_id: string;   // 关联的游戏对话
  version: number;
  code: string;              // 完整 HTML/ESM 代码
  script_snapshot: string;   // 生成时的剧本快照
  description?: string;
  created_at: timestamp;
}

// shares 表 (分享链接)
interface ShareLink {
  id: string;                // 短 ID，如 "abc123"
  game_id: string;
  created_by: string;        // 创建者 user_id
  access_count: number;
  last_accessed?: timestamp;
  created_at: timestamp;
}

// saves 表 (游戏存档)
interface GameSave {
  id: string;
  game_id: string;
  user_id: string;           // 玩家ID
  slot_number: number;
  state: GameState;          // 完整游戏状态
  play_time: number;         // 游戏时长(秒)
  created_at: timestamp;
  updated_at: timestamp;
}
```

---

## 四、页面与路由

```
/auth                 → 登录/注册页面 (Supabase Auth)

/workspace            → IDE 主工作区
  ├── /files          → 文件目录视图
  └── /chat/[id]      → 具体对话
        - 左侧: 全局文件目录树 + 对话列表
        - 中间: 文件编辑区 (可收起)
        - 右侧: 对话框
        - 底部: 游戏预览面板 (仅 game 类型对话)

/play/[shareId]       → 游戏游玩页面 (玩家入口)
  - 独立页面，无 IDE 元素
  - 游戏 UI (Agent B 生成)
  - Agent C 驱动剧情
  - 存档/读档功能

/api/chat             → AI 对话接口 (Agent A/B)
/api/game/stream      → 游戏实时流 (Agent C)
/api/saves            → 存档 CRUD
```

---

## 五、关键交互流程

### 流程 1：剧本 → 游戏 → 分享

```
1. 用户在 /workspace
   └─ 创建新对话 (type: script)
   └─ 与 Agent A 对话，编写剧本
   └─ Agent A 自动创建/更新文件

2. 用户说"生成游戏"
   └─ 前端调用 /api/chat (切换到 Agent B)
   └─ Agent B 读取当前剧本文件
   └─ 生成 HTML 游戏代码
   └─ 创建 game 类型的新对话
   └─ 跳转到 /workspace/chat/[game_conv_id]

3. 在游戏对话中
   └─ 底部显示游戏预览 (iframe)
   └─ 用户可与 Agent B 对话调整游戏
   └─ 每次生成新版本，版本列表增加

4. 用户点击「分享」
   └─ 创建 shares 记录
   └─ 生成链接 /play/abc123
   └─ 可复制分享
```

### 流程 2：玩家游玩

```
1. 玩家打开 /play/abc123
   └─ 加载游戏 HTML (Agent B 生成)
   └─ 查询自己的存档列表

2. 有存档？
   ├─ 是 → 显示「继续游戏」按钮
   └─ 否 → 显示「开始新游戏」

3. 开始游戏
   └─ 建立 SSE/WebSocket 连接到 /api/game/stream
   └─ 发送初始状态给 Agent C
   └─ Agent C 返回开场剧情

4. 游戏进行中
   ├─ 玩家选择选项 / 输入文字
   ├─ 前端发送动作到后端
   ├─ Agent C 处理，返回新剧情+状态更新
   ├─ 前端解析 XML，更新 UI
   └─ 自动保存状态到 saves 表

5. 玩家退出
   └─ 自动存档到当前槽位
   └─ 下次进入可继续
```

---

## 六、Agent C 实现细节

### 6.1 Prompt 设计

```typescript
const AGENT_C_SYSTEM_PROMPT = `
你是 DeepQeeb 游戏运行时引擎，负责驱动文字冒险游戏。

## 你的职责
1. 根据玩家输入推进剧情
2. 管理游戏状态（角色属性、物品、进度）
3. 输出结构化的剧情和状态更新

## 输出格式
你必须严格按照以下 XML 格式输出：

<dialogue>
  <speaker>角色名</speaker>
  <content>对话内容</content>
  <emotion>表情（可选）</emotion>
</dialogue>

<state_update>
{
  // 只包含需要更新的字段
}
</state_update>

## 状态管理规则
- 所有状态以 JSON 对象形式维护
- 只输出需要更新的字段，未提及的保持不变
- 支持的角色属性：name, age, identity, background, relationship
- 支持的全局变量：任何键值对

## 当前游戏状态
{{current_state}}

## 剧本背景
{{script_background}}
`;
```

### 6.2 状态更新合并策略

```typescript
// 前端接收状态更新后，与当前状态合并
function mergeState(current: GameState, update: Partial<GameState>): GameState {
  return {
    ...current,
    characters: {
      ...current.characters,
      ...update.characters,
    },
    variables: {
      ...current.variables,
      ...update.variables,
    },
    progress: {
      ...current.progress,
      ...update.progress,
      completedEvents: [
        ...current.progress.completedEvents,
        ...(update.progress?.completedEvents || []),
      ],
    },
    inventory: update.inventory || current.inventory,
    dialogueHistory: [
      ...current.dialogueHistory,
      newDialogueEntry,
    ].slice(-50), // 只保留最近50条
  };
}
```

---

## 七、技术挑战与解决方案

### 挑战 1：Agent C 的上下文长度

**问题**：游戏进行久了，对话历史会超出模型上下文限制。

**方案**：
- 只保留最近 20-30 轮对话在上下文中
- 对更早的对话进行「摘要」，提取关键信息
- 定期将完整状态快照保存到数据库

### 挑战 2：多人同时玩同一游戏

**问题**：同一个 share 链接，多个玩家同时玩，状态如何隔离？

**方案**：
- 每个玩家的存档完全独立 (user_id + game_id)
- Agent C 每次处理时根据 user_id 加载对应存档
- 游戏代码本身无状态，纯前端渲染

### 挑战 3：Agent C 与游戏 UI 的通信

**问题**：Agent B 生成的 UI 如何与 Agent C 输出的结构化数据对接？

**方案**：
- Agent B 生成游戏代码时，内置「协议解析器」
- 约定固定的 XML/JSON 格式
- 前端代码自动解析，无需每款游戏单独适配

```javascript
// Agent B 生成的游戏代码内置
function parseAgentCOutput(rawText) {
  const dialogue = parseXmlTag(rawText, 'dialogue');
  const stateUpdate = parseJsonTag(rawText, 'state_update');
  return { dialogue, stateUpdate };
}
```

---

## 八、开发优先级建议

### Phase 1：基础 IDE + Agent A
- [ ] 用户登录 (Supabase Auth)
- [ ] 三栏 IDE 布局
- [ ] 全局文件系统
- [ ] Agent A 对话接口

### Phase 2：Agent B + 游戏预览
- [ ] Agent B 代码生成
- [ ] iframe 游戏预览
- [ ] 游戏版本管理
- [ ] 分享功能

### Phase 3：Agent C + 游戏运行时
- [ ] Agent C 结构化输出
- [ ] 游戏页面 /play/[id]
- [ ] 存档系统
- [ ] 状态管理

### Phase 4：优化
- [ ] 多模态支持 (图片输入)
- [ ] 游戏素材生成
- [ ] 访问统计
- [ ] 社区分享

---

## 九、遗漏点检查

基于你的功能定义，检查是否还有遗漏：

| 功能定义 | 解决方案 | 状态 |
|---------|---------|------|
| 文件增删改查 | 全局文件系统 + 文件树组件 | ✅ |
| 查看文件与对话框占比 | 三栏可变布局，拖拽调整 | ✅ |
| 对话历史记录 | conversation 表 + 侧边栏列表 | ✅ |
| 随时续聊 | 加载 conversation + messages | ✅ |
| 创建新对话 | 「+ 新对话」按钮 | ✅ |
| 剧本转游戏 | 「一键进入」+ 创建 game 对话 | ✅ |
| 游戏预览 | 底部 iframe 面板 | ✅ |
| 分享功能 | shares 表 + /play/[id] | ✅ |
| 多个版本管理 | games 表 version 字段 | ✅ |
| 多次分享管理 | 一个 game 多个 share 记录 | ✅ |
| Agent C 状态管理 | XML state_update + saves 表 | ✅ |
| 存档功能 | saves 表 + 自动/手动存档 | ✅ |

**还有遗漏吗？** 或者对哪个部分需要更详细的设计？
